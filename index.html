#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <WiFiManager.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>

// ---------- Pins ----------
#define RELAY_PIN D1
#define TRIG_PIN  D5
#define ECHO_PIN  D6

ESP8266WebServer server(80);
bool contactorState = false;

// ---------- Tank Settings ----------
const float tankHeightInches = 52.0;
const float tankHeightCM = tankHeightInches * 2.54;

// ---------- Water smoothing ----------
float waterAvg = 0;
const float SMOOTHING = 0.2;   // 0.1–0.3 recommended

// ---------- MQTT ----------
const char* mqtt_server   = "93bad3def29641e399de9a7b9c676613.s1.eu.hivemq.cloud";
const int   mqtt_port     = 8883;
const char* mqtt_user     = "tohits";
const char* mqtt_password = "toh123@TOH";

WiFiClientSecure espClient;
PubSubClient client(espClient);

// ---------- Relay ----------
void updateStatus() {
  client.publish("motor/status", contactorState ? "ON" : "OFF", true);
}

void relayON() {
  digitalWrite(RELAY_PIN, LOW);   // active LOW
  contactorState = true;
  updateStatus();
}

void relayOFF() {
  digitalWrite(RELAY_PIN, HIGH);
  contactorState = false;
  updateStatus();
}

// ---------- MQTT Callback ----------
void callback(char* topic, byte* payload, unsigned int length) {
  String msg;
  for (unsigned int i = 0; i < length; i++) msg += (char)payload[i];

  if (String(topic) == "motor/control") {
    if (msg == "ON")  relayON();
    if (msg == "OFF") relayOFF();
  }

  if (String(topic) == "esp/reset") {
    if (msg == "RESET") {
      Serial.println("Remote reset command received");
      delay(500);
      ESP.restart();
    }
  }
}

// ---------- MQTT Reconnect with LWT ----------
void reconnectMQTT() {
  while (!client.connected()) {
    if (client.connect(
          "NodeMCU_Motor",
          mqtt_user,
          mqtt_password,
          "esp/status",   // LWT topic
          1,
          true,
          "OFFLINE")) {

      client.subscribe("motor/control");
      client.subscribe("esp/reset");
      updateStatus();

      // ONLINE status & IP
      client.publish("esp/status", "ONLINE", true);
      client.publish("esp/ip", WiFi.localIP().toString().c_str(), true);

    } else {
      delay(2000); // retry every 2 sec
    }
  }
}

// ---------- WATER LEVEL (STABLE) ----------
void checkWaterLevel() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  long duration = pulseIn(ECHO_PIN, HIGH, 30000);
  if (duration == 0) return;

  float distance = duration * 0.034 / 2.0;

  if (distance < 2.0 || distance > tankHeightCM + 20.0) return;

  float rawPercent =
    ((tankHeightCM - distance) / tankHeightCM) * 100.0;

  rawPercent = constrain(rawPercent, 0, 100);

  // smoothing
  waterAvg = (SMOOTHING * rawPercent) + ((1 - SMOOTHING) * waterAvg);

  // deadband ±2%
  if (abs(waterAvg - rawPercent) < 2) {
    rawPercent = waterAvg;
  }

  char buf[8];
  snprintf(buf, sizeof(buf), "%d", (int)waterAvg);
  client.publish("sensor/waterLevel", buf, true);
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);

  pinMode(RELAY_PIN, OUTPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  relayOFF();

  WiFiManager wm;
  wm.autoConnect("MotorControllerAP");

  espClient.setInsecure();
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);

  server.begin();
}

// ---------- Loop ----------
unsigned long lastWater = 0;
unsigned long lastUptime = 0;

void loop() {
  server.handleClient();

  if (!client.connected()) reconnectMQTT();
  client.loop();

  unsigned long now = millis();

  // Water level every 5 sec
  if (now - lastWater > 5000) {
    checkWaterLevel();
    lastWater = now;
  }

  // Uptime every 1 sec
  if (now - lastUptime > 1000) {
    unsigned long totalSec = now / 1000;
    unsigned int hrs  = totalSec / 3600;
    unsigned int mins = (totalSec % 3600) / 60;
    unsigned int secs = totalSec % 60;

    char up[16];
    snprintf(up, sizeof(up), "%02u:%02u:%02u", hrs, mins, secs);
    client.publish("esp/uptime", up, true);

    lastUptime = now;
  }
}
